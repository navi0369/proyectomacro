### b6b10ea – 2025-06-20 (2025-06-20)

diff --git a/config.py b/config.py
index 5e38ceb..080a302 100644
--- a/config.py
+++ b/config.py
@@ -9,20 +9,19 @@ CYCLES={
     "Expansión 86-99": slice(1986, 1999),
     "Crisis 00-05": slice(2000, 2005),
     "Expansión 06-13": slice(2006, 2013),
-    "Recesión 14-23": slice(2014, 2023),
-
+    "Recesión 14-24": slice(2014, 2024),
 }
 CYCLES_SIN_CRISIS = {
     "Expansión 50-70": slice(1950, 1970),
     "Recesión 71-84":  slice(1971, 1984),
     "Expansión 85-05": slice(1985, 2005),
     "Expansión 06-14": slice(2006, 2014),
-    "Recesión 15-22":  slice(2015, 2022),
+    "Recesión 15-24":  slice(2015, 2024),
 }
 CYCLES_PERIODOS= {
-    "1950-1984":   slice(1950, 1984),
-    "1985-2005":   slice(1985, 2005),
-    "2006-2022":   slice(2006, 2022),
+    "Intervensionismo-estatal 50-84":   slice(1950, 1984),
+    "Neoliberalismo 85-05":   slice(1985, 2005),
+    "Neodesarrollismo 06-24":   slice(2006, 2024),
 } 
 #hitos verticales hitos principales
 hitos_v = {
@@ -45,14 +44,23 @@ hitos_v_periodos = {
 }
 
 #anotaciones en la grafica
+annot_years = [1952,1956,1970,1982, 1986, 2000, 2006,2014, 2023]
 annot_years_sin_crisis = [1950,1971,1985, 2005, 2015,2022]
 annot_years_periodos = [1950,1985,2006,2022]
 #anotaciones de tasas, sin crisis
+periodos_tasas=[
+    (1956, 1970),
+    (1970, 1986),
+    (1986, 2000),
+    (2000, 2006),
+    (2006, 2014),
+    (2014, 2022),
+]
 periodos_tasas_sin_crisis = [
     (1950, 1970),
     (1971, 1984),
     (1985, 2005),
-    (2005, 2014),
+    (2006, 2014),
     (2015,2022)
 ]
 periodos_tasas_periodos = [
diff --git a/notebooks/tesis/serie_completa/config.py b/notebooks/tesis/serie_completa/config.py
index ee3d262..5dcc6b6 100644
--- a/notebooks/tesis/serie_completa/config.py
+++ b/notebooks/tesis/serie_completa/config.py
@@ -9,20 +9,19 @@ CYCLES={
     "Expansión 86-99": slice(1986, 1999),
     "Crisis 00-05": slice(2000, 2005),
     "Expansión 06-13": slice(2006, 2013),
-    "Recesión 14-23": slice(2014, 2023),
-
+    "Recesión 14-24": slice(2014, 2024),
 }
 CYCLES_SIN_CRISIS = {
     "Expansión 50-70": slice(1950, 1970),
     "Recesión 71-84":  slice(1971, 1984),
     "Expansión 85-05": slice(1985, 2005),
     "Expansión 06-14": slice(2006, 2014),
-    "Recesión 15-22":  slice(2015, 2022),
+    "Recesión 15-24":  slice(2015, 2024),
 }
 CYCLES_PERIODOS= {
-    "1950-1984":   slice(1950, 1984),
-    "1985-2005":   slice(1985, 2005),
-    "2006-2022":   slice(2006, 2022),
+    "Intervensionismo-estatal 50-84":   slice(1950, 1984),
+    "Neoliberalismo 85-05":   slice(1985, 2005),
+    "Neodesarrollismo 06-24":   slice(2006, 2024),
 } 
 #hitos verticales hitos principales
 hitos_v = {
@@ -45,13 +44,27 @@ hitos_v_periodos = {
 }
 
 #anotaciones en la grafica
+annot_years = [1952,1956,1970,1982, 1986, 2000, 2006,2014, 2023]
 annot_years_sin_crisis = [1950,1971,1985, 2005, 2015,2022]
 annot_years_periodos = [1950,1985,2006,2022]
-#anotaciones de tasas, sin crisis
+#anotaciones de tasas con crisis
+periodos_tasas=[
+    (1956, 1970),
+    (1970, 1982),
+    (1986, 2000),
+    (2000, 2006),
+    (2006, 2014),
+    (2014, 2022),
+]
 periodos_tasas_sin_crisis = [
     (1950, 1970),
     (1971, 1984),
     (1985, 2005),
-    (2005, 2014),
+    (2006, 2014),
     (2015,2022)
 ]
+periodos_tasas_periodos = [
+    (1950, 1984)
+    (1985, 2005),
+    (2006, 2022)
+]
\ No newline at end of file
diff --git a/notebooks/tesis/serie_completa/graficos_utils.py b/notebooks/tesis/serie_completa/graficos_utils.py
index ec128d0..b69f3a2 100644
--- a/notebooks/tesis/serie_completa/graficos_utils.py
+++ b/notebooks/tesis/serie_completa/graficos_utils.py
@@ -3,110 +3,132 @@ from matplotlib.lines import Line2D
 import matplotlib.pyplot as plt
 import sqlite3
 from pathlib import Path
-from typing import Dict, List, Tuple
+from typing import Dict, List, Tuple, Optional
 import logging
-
+import numpy as np
 logger = logging.getLogger(__name__)
 # graficos_utils.py
-def adjust_cycles(
-    df: pd.DataFrame,
-    cycles: Dict[str, slice],
-) -> Dict[str, slice]:
-    """Devuelve un *nuevo* dict de ciclos recortado al rango de df.
-
-    Mantiene las claves originales cuando el slice no cambia; renombra
-    solo si el rango efectivo difiere del nominal.
 
-    Parámetros
-    ----------
-    df : pd.DataFrame
-        DataFrame con índice de años.
-    cycles : Dict[str, slice]
-        Diccionario con nombres de ciclos y sus rangos nominales.
-
-    Returns
-    -------
-    Dict[str, slice]
-        Diccionario con slices ajustados a [df.index.min(), df.index.max()].
-        Si el rango ajustado es distinto al original, la clave se actualiza para
-        reflejar el nuevo inicio y fin. Ciclos sin datos se omiten.
-    """
+def adjust_cycles(df: pd.DataFrame, cycles: dict[str, slice]) -> dict[str, slice]:
     if df.empty:
-        raise ValueError("El DataFrame está vacío; no hay años para ajustar.")
+        raise ValueError("DF vacío")
 
-    min_year, max_year = int(df.index.min()), int(df.index.max())
-    cycles_adj: Dict[str, slice] = {}
+    min_year, max_year = map(int, [df.index.min(), df.index.max()])
+    # — 1. encontrar el slice con stop más grande —
+    last_nominal_stop = max(sl.stop for sl in cycles.values())
+    cycles_adj = {}
 
     for name, sl in cycles.items():
-        # Ajusta límites al rango disponible
         start = max(sl.start, min_year)
-        stop = min(sl.stop, max_year)
 
-        if start <= stop:
-            # Caso 1: rango coincide con el definido
-            if start == sl.start and stop == sl.stop:
-                cycles_adj[name] = slice(start, stop)
-            else:
+        # — 2. si es el último ciclo, usamos max_year como fin —
+        stop_incl = max_year if sl.stop == last_nominal_stop else min(sl.stop, max_year)
+
+        if start <= stop_incl:
+            # Pandas .loc es inclusivo, así que usamos stop_incl tal cual
+            new_key = name
+            if start != sl.start or stop_incl != sl.stop:
                 base = name.rsplit(" ", 1)[0]
-                yy_s = f"{start % 100:02d}"
-                yy_e = f"{stop  % 100:02d}"
-                new_key = f"{base} {yy_s}-{yy_e}"
-                cycles_adj[new_key] = slice(start, stop)
+                new_key = f"{base} {start%100:02d}-{stop_incl%100:02d}"
+
+            cycles_adj[new_key] = slice(start, stop_incl)
         else:
-            logger.warning("Ciclo '%s' ignorado: sin datos en df", name)
+            logger.warning("Ciclo %s ignorado (fuera de rango)", name)
 
     return cycles_adj
-def align_plot_params(
+
+def adjust_periods(
     df: pd.DataFrame,
-    cycles: Dict[str, slice],
-    hitos: Dict[int, str],
-    annotate_years: List[int],
     periods: List[Tuple[int, int]],
-) -> Tuple[Dict[str, slice], Dict[int, str], List[int], List[Tuple[int, int]]]:
-    """Recorta diccionarios/listas para que coincidan con el rango temporal de *df*.
-
-    Evita ``KeyError`` cuando la tabla no cubre todo el horizonte definido en
-    ``config.py``.
+    required_cols: Optional[List[str]] = None,
+    min_nonzero: int = 1
+) -> List[Tuple[int, int]]:
+    """
+    Ajusta los períodos nominales a lo que realmente existe en `df`
+    y extiende el ÚLTIMO período hasta el máximo año en que TODAS
+    las `required_cols` tienen datos válidos (no NaN, ≠0).
 
-    Returns
-    -------
-    cycles_adj, hitos_adj, annotate_years_adj, periods_adj
-        Versiones *filtradas* y/o *recortadas* que encajan con el índice de
-        ``df``. Si un slice o periodo queda vacío se descarta.
+    Parámetros
+    ----------
+    df : DataFrame con índice numérico (años).
+    periods : lista [(ini, fin), ...] nominal.
+    required_cols : columnas que deben tener datos válidos.
+                    Si None, usa todas las columnas numéricas.
+    min_nonzero : nº mínimo de valores válidos por período
+                  para que éste se conserve.
     """
     if df.empty:
-        raise ValueError("El DataFrame está vacío, nada que alinear.")
+        return []
 
-    min_year: int = int(df.index.min())
-    max_year: int = int(df.index.max())
+    if required_cols is None:
+        required_cols = [
+            c for c in df.columns
+            if np.issubdtype(df[c].dtype, np.number)
+        ]
 
-    # 1) Ciclos --------------------------------------------------------------
-    cycles_adj: Dict[str, slice] = {}
-    for name, sl in cycles.items():
-        start = max(sl.start, min_year)
-        stop = min(sl.stop, max_year)
-        if start <= stop:
-            cycles_adj[name] = slice(start, stop)
-        else:
-            logger.warning("Ciclo '%s' ignorado: sin datos en df", name)
+    years = df.index.astype(int)
+    min_year, max_year = years.min(), years.max()
 
-    # 2) Hitos ---------------------------------------------------------------
-    hitos_adj = {yr: lbl for yr, lbl in hitos.items() if min_year <= yr <= max_year}
+    # -- helper: cuántos valores válidos hay por periodo
+    def valid_count(lo, hi):
+        sub = df.loc[lo:hi, required_cols]
+        return ((sub.notna()) & (sub != 0)).sum().sum()
 
-    # 3) Años de anotación ---------------------------------------------------
-    annotate_years_adj = [yr for yr in annotate_years if min_year <= yr <= max_year]
+    adjusted = []
 
-    # 4) Periodos para tasas -------------------------------------------------
-    periods_adj: List[Tuple[int, int]] = []
-    for vi, vf in periods:
-        adj_vi = max(vi, min_year)
-        adj_vf = min(vf, max_year)
-        if adj_vi <= adj_vf:
-            periods_adj.append((adj_vi, adj_vf))
-        else:
-            logger.warning("Periodo %s-%s omitido: fuera de rango", vi, vf)
+    for idx, (start, stop) in enumerate(periods):
+        lo = max(start, min_year)
+        hi = min(stop,  max_year)
+        if lo > hi:
+            continue
+
+        # recorte al rango real de años disponibles
+        available = years[(years >= lo) & (years <= hi)]
+        if available.empty:
+            continue
+
+        lo2, hi2 = available.min(), available.max()
+
+        # filtro por datos válidos
+        if valid_count(lo2, hi2) < min_nonzero:
+            continue
+
+        adjusted.append((int(lo2), int(hi2)))
+
+    # ---------------------------
+    # Empujar el ÚLTIMO período
+    # ---------------------------
+    if adjusted:
+        # último año donde TODAS las columnas tienen dato válido
+        mask_valid = (df[required_cols].notna() & (df[required_cols] != 0)).all(axis=1)
+        if mask_valid.any():
+            last_valid_year = int(df.index[mask_valid].max())
+            # sustituir el 'stop' de la última tupla si podemos crecer
+            lo_last, hi_last = adjusted[-1]
+            if last_valid_year > hi_last:
+                adjusted[-1] = (lo_last, last_valid_year)
+
+    return adjusted
+def adjust_annot_years(df: pd.DataFrame, years: List[int]) -> List[int]:
+    """
+    Filtra y ajusta la lista `years` para que:
+      1. Queden solo los años entre el primer y último año de df.index.
+      2. El primer elemento sea siempre df.index.min().
+      3. El último elemento sea siempre df.index.max().
+      4. No haya duplicados, ni viejos valores iguales al máximo salvo el final.
+
+    """
+    idx = df.index.astype(int)
+    min_year, max_year = idx.min(), idx.max()
+
+    # 1) solo los años dentro del rango
+    in_range = sorted({yr for yr in years if min_year <= yr <= max_year})
+
+    # 2) quedarnos solo con los que estén *strictly* entre min y max
+    mid_years = [yr for yr in in_range if min_year < yr < (max_year-2)]
 
-    return cycles_adj, hitos_adj, annotate_years_adj, periods_adj
+    # 3) reconstruir lista con min + medios + max
+    return [min_year] + mid_years + [max_year]
 
 
 def get_df(
@@ -201,114 +223,46 @@ def set_style() -> None:
     'figure.dpi':   150,
     'savefig.bbox': 'tight',
     })
-
-
-def cycle_stats(
-    df: pd.DataFrame,
-    periods: list[tuple[int, int]],
-    cols: list[str],
-    kind: str = "mean"
-) -> dict[str, dict[str, float]]:
-    """
-    Calcula estadísticas por ciclo para columnas dadas.
-
-    Parámetros
-    ----------
-    df : pd.DataFrame
-        DataFrame con índice de años.
-    periods : list of (int, int)
-        Lista de tuplas (inicio, fin) de periodos.
-    cols : list[str]
-        Columnas sobre las que calcular estadísticas.
-    kind : str
-        Tipo de estadística: 'mean', 'growth'.
-
-    Devuelve
-    --------
-    dict[str, dict[str, float]]
-        { 'vi-vf': {col: valor} } donde valor = media o tasa de crecimiento.
-    """
-    stats = {}
-    for vi, vf in periods:
-        key = f"{vi}-{vf}"
-        sub = df.loc[vi:vf, cols]
-        if kind == "mean":
-            stats[key] = sub.mean().to_dict()
-        elif kind == "growth":
-            stats[key] = ((sub.loc[vf] / sub.loc[vi] - 1) * 100).to_dict()
-    return stats
-
-
-def plot_dual_axis(
-    df: pd.DataFrame,
-    y1: str,
-    y2: str,
-    *,
+def init_base_plot(
+    df,
+    series: list[tuple[str,str]],
+    colors: dict[str,str],
     title: str,
-    colors: dict[str, str],
-    periods: list[tuple[int, int]],
-    hitos: dict[str, dict],
-    out: str,
-    base_dir: str = "assets"
-) -> None:
+    xlabel: str,
+    ylabel: str,
+    figsize: tuple[int,int]=(13,8),
+    legend_loc: str="upper left",
+    legend_ncol: int=3,
+    source_text: str="Fuente: Elaboración propia con datos de UDAPE"
+):
     """
-    Genera y guarda un gráfico con eje dual (y1 vs y2).
-
-    Parámetros
-    ----------
-    df : pd.DataFrame
-        DataFrame con índice de años y columnas y1, y2.
-    y1 : str
-        Nombre de la columna para el eje izquierdo.
-    y2 : str
-        Nombre de la columna para el eje derecho.
-    title : str
-        Título del gráfico.
-    colors : dict[str, str]
-        Colores para y1 y y2 {col: color_hex}.
-    periods : list of (int, int)
-        Periodos para anotaciones de ciclo.
-    hitos : dict[str, dict]
-        Diccionario con claves:
-        - 'labels': {año: etiqueta}
-        - 'offsets': {año: factor}
-        - 'cycle_txt_off': {periodo: (x, y_frac)}
-    out : str
-        Ruta y nombre de archivo (sin extensión) para guardar.
-    base_dir : str
-        Directorio base donde escribir la imagen.
+    Inicializa fig y ax con:
+     - series: lista de tuplas (columna, etiqueta)
+     - colors: dict columna→color
+     - titulación de ejes y leyenda
+     - pie de fuente
     """
-    fig, ax1 = plt.subplots(figsize=(12, 7))
-    ax2 = ax1.twinx()
-
-    ax1.plot(df.index, df[y1], label=y1, color=colors[y1])
-    ax2.plot(df.index, df[y2], label=y2, color=colors[y2])
-
-    add_hitos(ax1, df.index, hitos['labels'], hitos['offsets'])
-
-    stats = cycle_stats(df, periods, [y1, y2], kind="mean")
-    add_cycle_means_multi(
-        ax1,
-        stats,
-        hitos['cycle_txt_off'],
-        {y1: 'Y1', y2: 'Y2'},
-        colors,
-        line_spacing=df[y1].max() * 0.03,
-        value_fmt="{:.1f}"
+    fig, ax = plt.subplots(figsize=figsize)
+    for col, label in series:
+        ax.plot(df.index, df[col], label=label, color=colors[col])
+
+    ax.set_title(title, fontweight='bold')
+    ax.set_xlabel(xlabel)
+    ax.set_ylabel(ylabel)
+    ax.set_xticks(df.index[::max(1, len(df)//31)])
+    ax.tick_params(axis='x', rotation=45)
+    ax.legend(loc=legend_loc, ncol=legend_ncol, fontsize=12)
+
+    fig.text(
+        0.07, 0.005,
+        source_text,
+        ha="left", va="bottom",
+        fontsize=12, color="black",
+        transform=fig.transFigure
     )
+    plt.tight_layout()
+    return fig, ax
 
-    ax1.set_title(title, fontweight="bold")
-    ax1.set_xlabel("Año")
-    ax1.set_ylabel(y1, color=colors[y1])
-    ax2.set_ylabel(y2, color=colors[y2])
-    ax1.tick_params(axis="x", rotation=45)
-
-    handles1, labels1 = ax1.get_legend_handles_labels()
-    handles2, labels2 = ax2.get_legend_handles_labels()
-    ax1.legend(handles1 + handles2, labels1 + labels2, loc="upper left")
-
-    fig.tight_layout()
-    save_fig(fig, out, base_dir=base_dir)
 
 # guarda esto en, por ejemplo, graficos_utils.py
 def add_hitos(
@@ -429,6 +383,13 @@ def add_period_growth_annotations_multi(
 
         # 2) Bloque de tasas (una línea por componente)
         for i, col in enumerate(cols):
+            v_ini = df.loc[vi, col]
+            v_fin = df.loc[vf, col]
+            umbral = 1e-2   # por ejemplo, 0.01
+            if abs(v_ini) < umbral or abs(v_fin) < umbral:
+                continue
+            if pd.isna(v_ini) or pd.isna(v_fin) or v_ini == 0 or v_fin == 0:
+                continue        # salta esta columna si falta dato útil
             tasa = round((df.loc[vf, col] / df.loc[vi, col] - 1) * 100)
             y = y0 - (i + 1) * line_spacing
 
@@ -582,7 +543,10 @@ def add_year_value_annotations(
         vals = [(df.loc[yr, col], col) for col in columnas]
         vals.sort(key=lambda t: t[0])
         for y, col in vals:
-            dx, dy = annotation_offsets.get(col, {}).get(yr, (0, 0))
+            offsets_for_col = annotation_offsets.get(col)
+            if not offsets_for_col or yr not in offsets_for_col:
+                continue
+            dx, dy = offsets_for_col[yr]
             ax.annotate(
                 value_fmt.format(y),
                 xy=(yr, y),
@@ -664,7 +628,9 @@ def add_participation_cycle_boxes(
         # crea el slice de años y la clave para offsets
         period_slice = slice(vi, vf)
         key = f"{vi}-{vf}"
-
+        # validar existencia de offset
+        if key not in offsets:
+            continue
         # recorta datos y calcula %
         df_period = df.loc[period_slice, components + [total_col]].dropna()
         pct = df_period[components].div(df_period[total_col], axis=0) * 100
